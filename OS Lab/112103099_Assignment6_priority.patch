diff --git a/Makefile b/Makefile
index 09d790c..785f353 100644
--- a/Makefile
+++ b/Makefile
@@ -181,6 +181,7 @@ UPROGS=\
 	_usertests\
 	_wc\
 	_zombie\
+	_priority_usertest\
 
 fs.img: mkfs README $(UPROGS)
 	./mkfs fs.img README $(UPROGS)
diff --git a/defs.h b/defs.h
index 82fb982..a609a2e 100644
--- a/defs.h
+++ b/defs.h
@@ -120,6 +120,7 @@ void            userinit(void);
 int             wait(void);
 void            wakeup(void*);
 void            yield(void);
+int		chpriority(int pid, int priority); //priority scheduling implement
 
 // swtch.S
 void            swtch(struct context**, struct context*);
diff --git a/exec.c b/exec.c
index b40134f..bef8087 100644
--- a/exec.c
+++ b/exec.c
@@ -6,6 +6,8 @@
 #include "defs.h"
 #include "x86.h"
 #include "elf.h"
+#define DEFAULT_PRIORITY 10
+#define CURRENT_PRIORITY 2
 
 int
 exec(char *path, char **argv)
@@ -99,6 +101,8 @@ exec(char *path, char **argv)
   curproc->sz = sz;
   curproc->tf->eip = elf.entry;  // main
   curproc->tf->esp = sp;
+  // set current process's priority
+  curproc->priority = CURRENT_PRIORITY;
   switchuvm(curproc);
   freevm(oldpgdir);
   return 0;
diff --git a/kalloc.c b/kalloc.c
index 14cd4f4..7b06990 100644
--- a/kalloc.c
+++ b/kalloc.c
@@ -2,49 +2,57 @@
 // memory for user processes, kernel stacks, page table pages,
 // and pipe buffers. Allocates 4096-byte pages.
 
+//changed code to use array inplace of list - OS Assignment 5 (112103099)
+
 #include "types.h"
 #include "defs.h"
 #include "param.h"
 #include "memlayout.h"
 #include "mmu.h"
 #include "spinlock.h"
+#define MAX_ARR_SIZE (PHYSTOP/PGSIZE) 
 
 void freerange(void *vstart, void *vend);
 extern char end[]; // first address after kernel loaded from ELF file
                    // defined by the kernel linker script in kernel.ld
 
-struct run {
+struct run 
+{
   struct run *next;
+  //array was added here
+  char* free_arr [MAX_ARR_SIZE];   
+  int free_arr_size;
+
 };
 
-struct {
+struct 
+{
   struct spinlock lock;
   int use_lock;
-  struct run *freelist;
+  struct run freeArr;
 } kmem;
 
+
 // Initialization happens in two phases.
 // 1. main() calls kinit1() while still using entrypgdir to place just
 // the pages mapped by entrypgdir on free list.
 // 2. main() calls kinit2() with the rest of the physical pages
 // after installing a full page table that maps them on all cores.
-void
-kinit1(void *vstart, void *vend)
+void kinit1(void *vstart, void *vend)
 {
   initlock(&kmem.lock, "kmem");
   kmem.use_lock = 0;
+  kmem.freeArr.free_arr_size = 0;
   freerange(vstart, vend);
 }
 
-void
-kinit2(void *vstart, void *vend)
+void kinit2(void *vstart, void *vend)
 {
   freerange(vstart, vend);
   kmem.use_lock = 1;
 }
 
-void
-freerange(void *vstart, void *vend)
+void freerange(void *vstart, void *vend)
 {
   char *p;
   p = (char*)PGROUNDUP((uint)vstart);
@@ -56,10 +64,10 @@ freerange(void *vstart, void *vend)
 // which normally should have been returned by a
 // call to kalloc().  (The exception is when
 // initializing the allocator; see kinit above.)
-void
-kfree(char *v)
+
+void kfree(char *v)
 {
-  struct run *r;
+  //struct run *r;    //will use array instead
 
   if((uint)v % PGSIZE || v < end || V2P(v) >= PHYSTOP)
     panic("kfree");
@@ -68,29 +76,66 @@ kfree(char *v)
   memset(v, 1, PGSIZE);
 
   if(kmem.use_lock)
+  {
     acquire(&kmem.lock);
-  r = (struct run*)v;
-  r->next = kmem.freelist;
-  kmem.freelist = r;
+  }
+  //r = (struct run*)v;
+  //r->next = kmem.freelist;
+  //kmem.freelist = r;
+  
+  //check if array size is less than the max size possible
+  if (kmem.freeArr.free_arr_size < MAX_ARR_SIZE) 
+  {   
+	  kmem.freeArr.free_arr[kmem.freeArr.free_arr_size] = v;    //add it to the free array
+	  kmem.freeArr.free_arr_size++;
+  }
+  else 
+  {
+       panic("Array size exceeded\n");
+  }
+
+  //keep this code as it is
   if(kmem.use_lock)
+  {
     release(&kmem.lock);
+  }
 }
 
 // Allocate one 4096-byte page of physical memory.
 // Returns a pointer that the kernel can use.
 // Returns 0 if the memory cannot be allocated.
-char*
-kalloc(void)
+
+char* kalloc(void)
 {
-  struct run *r;
+  //struct run *r;
+  char* allocateNewPage = 0;
 
   if(kmem.use_lock)
-    acquire(&kmem.lock);
-  r = kmem.freelist;
-  if(r)
-    kmem.freelist = r->next;
+  {
+	  acquire(&kmem.lock);
+  }
+  //r = kmem.freelist;
+  //if(r)
+    //kmem.freelist = r->next;
+
+  int currentIndex = kmem.freeArr.free_arr_size;
+
+  if(currentIndex > 0)
+  {
+	  currentIndex--;
+	  allocateNewPage = kmem.freeArr.free_arr[currentIndex];
+	  kmem.freeArr.free_arr_size = currentIndex;
+  }
+  else
+  {
+	  panic("Index out of lower bound\n");
+  }
+
   if(kmem.use_lock)
+  {
     release(&kmem.lock);
-  return (char*)r;
+  }
+  //return (char*)r;
+  return allocateNewPage;
 }
 
diff --git a/lapic.c b/lapic.c
index b22bbd7..25c9bac 100644
--- a/lapic.c
+++ b/lapic.c
@@ -9,6 +9,8 @@
 #include "traps.h"
 #include "mmu.h"
 #include "x86.h"
+#include "lapic.h"
+#define DEFAULT_TIME_QUANTUM 10000000
 
 // Local APIC registers, divided by 4 for use as uint[] indices.
 #define ID      (0x0020/4)   // ID
@@ -105,6 +107,14 @@ lapicid(void)
   return lapic[ID] >> 24;
 }
 
+//self function for generating time quantum priority
+void time_quantum_priority(int priority)
+{
+	int set_time_quantum = DEFAULT_TIME_QUANTUM / priority;
+	lapicw(TICR, set_time_quantum);
+}
+
+
 // Acknowledge interrupt.
 void
 lapiceoi(void)
diff --git a/proc.c b/proc.c
index 806b1b1..11a3826 100644
--- a/proc.c
+++ b/proc.c
@@ -6,6 +6,9 @@
 #include "x86.h"
 #include "proc.h"
 #include "spinlock.h"
+#include "lapic.h"
+#define DEFAULT_PRIORITY 10
+#define CURRENT_PRIORITY 2
 
 struct {
   struct spinlock lock;
@@ -70,8 +73,7 @@ myproc(void) {
 // If found, change state to EMBRYO and initialize
 // state required to run in the kernel.
 // Otherwise return 0.
-static struct proc*
-allocproc(void)
+static struct proc* allocproc(void)
 {
   struct proc *p;
   char *sp;
@@ -79,14 +81,24 @@ allocproc(void)
   acquire(&ptable.lock);
 
   for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+  {
     if(p->state == UNUSED)
+    {
       goto found;
-
+    }
+  }
   release(&ptable.lock);
   return 0;
 
 found:
   p->state = EMBRYO;
+
+  //give the priority as '10' as default for all processes
+  p->priority = DEFAULT_PRIORITY;
+
+  //initialize Slices to zero
+  p->currentSlice = 0;
+  p->extraSlice = 0;
   p->pid = nextpid++;
 
   release(&ptable.lock);
@@ -319,22 +331,60 @@ wait(void)
 //  - swtch to start running that process
 //  - eventually that process transfers control
 //      via swtch back to the scheduler.
-void
-scheduler(void)
+void scheduler(void)
 {
   struct proc *p;
   struct cpu *c = mycpu();
+
+  //create a temporary process
+  struct proc* tempProcess;
+
+  //create a higher priority temp process
+  struct proc* highProcess;
+  
   c->proc = 0;
   
-  for(;;){
+  //Infinite loop
+  for(;;)
+  {
     // Enable interrupts on this processor.
     sti();
 
     // Loop over process table looking for process to run.
     acquire(&ptable.lock);
-    for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+
+    for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+    {
       if(p->state != RUNNABLE)
+      {
         continue;
+      }
+
+	// Assume the current process is the one with the highest priority
+      highProcess = p;
+	
+	// Iterate through the process table to find a process with higher priority
+      tempProcess = ptable.proc;
+      
+      while (tempProcess < &ptable.proc[NPROC]) 
+      {
+	      // Check if the process is runnable and has higher priority
+	    if (tempProcess->priority < highProcess->priority) 
+	    {
+		if (tempProcess->state == RUNNABLE) 
+		{
+		    highProcess = tempProcess;
+		}
+	    }
+	    tempProcess++;
+	}
+
+      p = highProcess;
+
+      time_quantum_priority(p->priority);
+
+      switchuvm(p);
+
 
       // Switch to chosen process.  It is the process's job
       // to release ptable.lock and then reacquire it
@@ -343,6 +393,8 @@ scheduler(void)
       switchuvm(p);
       p->state = RUNNING;
 
+      p->currentSlice = p->extraSlice;    //make the current slice equal to the extra slice
+
       swtch(&(c->scheduler), p->context);
       switchkvm();
 
@@ -532,3 +584,32 @@ procdump(void)
     cprintf("\n");
   }
 }
+
+// added function to change priority of a process
+int chpriority(int pid, int priority) 
+{
+    struct proc *p;
+
+    // Acquire the process table lock
+    acquire(&ptable.lock);
+
+    // Start with the first process in the process table
+    p = ptable.proc;
+
+    // Simple linear search approach
+    while (p < &ptable.proc[NPROC]) 
+    {
+        if (p->pid == pid) 
+        {
+            // Update the priority of the process
+            p->priority = priority;
+            break;
+        }
+        p++;
+    }
+
+    release(&ptable.lock);
+
+    return pid;
+}
+
diff --git a/proc.h b/proc.h
index 1647114..c28af01 100644
--- a/proc.h
+++ b/proc.h
@@ -49,6 +49,9 @@ struct proc {
   struct file *ofile[NOFILE];  // Open files
   struct inode *cwd;           // Current directory
   char name[16];               // Process name (debugging)
+int priority; //priority of the process
+int extraSlice;   //extra slice for the process
+int currentSlice;  //current slice for the process
 };
 
 // Process memory is laid out contiguously, low addresses first:
diff --git a/syscall.c b/syscall.c
index ee85261..efefb08 100644
--- a/syscall.c
+++ b/syscall.c
@@ -103,6 +103,7 @@ extern int sys_unlink(void);
 extern int sys_wait(void);
 extern int sys_write(void);
 extern int sys_uptime(void);
+extern int sys_chpriority(void);
 
 static int (*syscalls[])(void) = {
 [SYS_fork]    sys_fork,
@@ -126,6 +127,7 @@ static int (*syscalls[])(void) = {
 [SYS_link]    sys_link,
 [SYS_mkdir]   sys_mkdir,
 [SYS_close]   sys_close,
+[SYS_chpriority]   sys_chpriority,
 };
 
 void
diff --git a/syscall.h b/syscall.h
index bc5f356..1963812 100644
--- a/syscall.h
+++ b/syscall.h
@@ -20,3 +20,4 @@
 #define SYS_link   19
 #define SYS_mkdir  20
 #define SYS_close  21
+#define SYS_chpriority  22
diff --git a/sysproc.c b/sysproc.c
index 0686d29..3135f0f 100644
--- a/sysproc.c
+++ b/sysproc.c
@@ -89,3 +89,15 @@ sys_uptime(void)
   release(&tickslock);
   return xticks;
 }
+
+int sys_chpriority(void)
+{
+  int pid, priority;
+  // Retrieve the process ID and priority from the first and second argument
+  if(argint(0, &pid) < 0 || argint(1,&priority) < 0)
+  {
+    return -1;
+  }
+
+  return chpriority(pid, priority);
+}
diff --git a/user.h b/user.h
index 4f99c52..923055b 100644
--- a/user.h
+++ b/user.h
@@ -23,6 +23,7 @@ int getpid(void);
 char* sbrk(int);
 int sleep(int);
 int uptime(void);
+int chpriority(int pid, int priority);
 
 // ulib.c
 int stat(const char*, struct stat*);
diff --git a/usys.S b/usys.S
index 8bfd8a1..9352953 100644
--- a/usys.S
+++ b/usys.S
@@ -29,3 +29,4 @@ SYSCALL(getpid)
 SYSCALL(sbrk)
 SYSCALL(sleep)
 SYSCALL(uptime)
+SYSCALL(chpriority)
